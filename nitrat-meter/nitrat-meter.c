/*==========Программа прошивки Ind_nitr 1.0a==========*/
//Индикатор нитратов на МК ATmega32A и ЖКИ Nokia-3310
//Компилятор Си: WinAVR-20060125
//Make: Name=Ind_nitr,MCU=ATmega32,Level=2,Debug=VMLab,Programmer=ponyser,Port=com1
/*Фьюзы МК: CKSEL3=CKSEL2=CKSEL0=0 (Внутр.RC-генератор 2 МГц), CKOPT=1
            BODEN=SUT1=SUT0=0 (Схема BOD Ures<2,7В),
            EESAVE=0 (запрет стирания EEPROM программатором)
            ("0"-галочки установлены)*/
//Внутренний RC-генератор 2МГц, тактовая частота =2 МГц,
//Энергосберегающий режим PowerSave
//

#include <avr/io.h>                     //Подключение системной библиотеки
#include <avr/eeprom.h>                 //Подключение библиотеки работы с EEPROM
#include <avr/pgmspace.h>               //Подключение библиотеки массивов
#include <avr/interrupt.h>              //Подключение библиотеки обработки прерываний
#include <avr/sleep.h>                  //Подключение библиотеки энергосберегающих режимов
#include <avr/wdt.h>
#include <string.h>                     //Подключение библиотеки работы со строковыми функциями
#include <stdio.h>                      //Подключение библиотеки работы со строковыми функциями
#include <stdlib.h>                     //Подключение библиотеки работы со строковыми функциями
#include <util/delay.h>
#include <stdbool.h>
#include "n3310lcd.h"                   //Подключение библиотеки функция для LCD NOKIA 3310

#include "strings_data.h"
#define F_CPU	2000000

//Задание названий линиям портов
//кнопки:
# define ONOFF PINB2                     //Порт PINB2 - кнопка "Вкл./Выкл."
//датчики:
# define ZU PINB1                        //Порт PINB1 - подключение зарядного устройства
//выходы:
# define POWER PA2                       //Порт A2 - вкл./выкл.питания
# define CHARGE PB0                      //Порт B0 - вкл. зарядки аккумулятора
//Калибровочные константы
# define ZAR_POR 415                     //Порог прекращения зарядки аккумулятора = 4,15В
# define SDV_CONTR 2                     /*Начальное смещение при регулировке контрастности (для китайского дисплея)
                                           contrast+SDV_CONTR=(0...100)+(0...27)=0...127 (до установки цепи ограничения
                                           напряжения питания дисплея при программировании SDV_CONTR=27, после случайного
                                           обрыва цепи RESET от программатора SI-Prog дисплей видимо немного повредился,
                                           и при превышении контрастности >102 контрастность становится нулевой)
*/
/*---Инициализация табличных констант---*/
/*Таблица в flash-памяти для определения времени выключения питания по таймеру*/
const unsigned int PROGMEM masstoff[]=
            { 55000, 229, 458, 687, 1144 };
//taym_off:       0   1    2    3     4
//Время,мин.:   выкл. 1    2    3     5
//
/*Таблица в flash-памяти для определения времени выключения подсветки по таймеру*/
const unsigned char PROGMEM massloff[] =
//static unsigned char __attribute__ ((progmem)) massloff[]=
            { 255, 38, 57, 76, 114, 172, 228 };
//ligh_off:     0   1   2   3   4    5    6
//Время,сек.:выкл. 10  15  20  30   45   60
//
/*Массив в EEPROM-памяти статистики замеров*/
static unsigned char EEMEM mas_stat[36][20]=
{ { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //0 - Абрикос
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //1 - Арбуз
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //2 - Банан
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //3 - Баклажан
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //4 - Виноград
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //5 - Груша
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //6 - Зелень
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //7 - Дыня
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //8 - Капуста ранн.
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //9 - Капуста поздн.
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //10 - Кабачок
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //11 - Картофель
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //12 - Клубника
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //13 - Лук репчатый
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //14 - Лук зеленый
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //15 - Манго
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //16 - Морковь ранняя
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //17 - Морковь поздняя
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //18 - Мясо свежее
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //19 - Нектарин
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //20 - Огурец
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //21 - Перец сладкий
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //22 - Персик
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //23 - Помидор
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //24 - Редис
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //25 - Редька
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //26 - Салат
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //27 - Свекла
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //28 - Хурма
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //29 - Яблоко
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //30 - Польз.1
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //31 - Польз.2
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //32 - Польз.3
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //33 - Польз.4
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, //34 - Польз.5
  { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }  //35 - Польз.6
};
//
/*Массив в EEPROM-памяти максимальных и минимальных измеренных значений*/
static unsigned int EEMEM mas_lim[2][36];
//static unsigned __attribute__ ((section(".eeprom"))) int mas_lim[2][36];
//
/*Массив в EEPROM-памяти количества выполненных замеров для каждого продукта (36 байт)*/
static unsigned int EEMEM mas_Nzam[]=
//static unsigned __attribute__ ((section(".eeprom"))) int mas_Nzam[]=
{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
//
/*Массив в EEPROM-памяти пользовательских названий продуктов из 8 символов*/
static unsigned char EEMEM Emas_name[6][8]=
{ "Польз.1 ",
  "Польз.2 ",
  "Польз.3 ",
  "Польз.4 ",
  "Польз.5 ",
  "Польз.6 "
};
//
/*Массив данных для установки яркости подсветки*/
//const unsigned char PROGMEM mas_yark[]=
//static unsigned char __attribute__ ((progmem)) mas_yark[]=
//                      { 0, 214, 216, 218, 219, 221 };
//yark=                 0   1    2    3    4    5
//Iподсв.(10 Ом), мА    0   2    4    6    8    10
//Uвых.фильтра, В       0  2.52 2.54 2.56 2.58 2.60
//Ток подсветки: Iподсв.=(Uвых.фильтра-2,5В)/R
//Частота ШИМ на выходе OC2(PD7): 2МГц/256=7812,5 Гц
//OCR2=256*Uвых/Uпит-1
//
//

//
/*Массив для вывода сообщений из 3-х строк надписей по 11 символов каждая*/
const unsigned char PROGMEM tab_mes[6][6]=
{ { 1, 0, 2, 4, 3, 0 },                  //"Выключение!"
  { 1, 1, 2, 2, 4, 4 },                  //"Аккумулятор разряжен! Выключение!"
  { 1, 1, 2, 3, 4, 4 },                  //"Аккумулятор заряжен! Выключение!"
  { 1, 0, 2, 1, 3, 3 },                  //"Аккумулятор заряжен!"
  { 2, 5, 3, 6, 4, 0 },                  //"Статистика очищена!"
  { 2, 7, 3, 8, 4, 0 },                  //"Замер сохранён!"
//  y  n  y  n  y  n
//y=0...5 - номер строки дисплея
//n=0...4 - номер надписи из массива nadpis_mes[5][11]
};
//
//
//
/*Массив в flash-памяти для вывода шкалы статистики (84 байта)*/
const unsigned char PROGMEM skal_stat[]=
//static unsigned char __attribute__ ((progmem)) skal_stat[]=
{ 0x00,0x0F,0x02,0x0F,0x00,0x0D,0x00,0x0F,
  0x01,0x0E,0x00,0x00,0x01,0x01,0x03,0x01,
  0x01,0x07,0x01,0x01,0x03,0x01,0x01,0x07,
  0x01,0x01,0x03,0x01,0x01,0x07,0x01,0x01,
  0x03,0x01,0x01,0x07,0x01,0x01,0x03,0x01,
  0x01,0x0F,0x01,0x01,0x03,0x01,0x01,0x07,
  0x01,0x01,0x03,0x01,0x01,0x07,0x01,0x01,
  0x03,0x01,0x01,0x07,0x01,0x01,0x03,0x01,
  0x01,0x07,0x01,0x01,0x03,0x01,0x01,0x0F,
  0x00,0x0F,0x02,0x0F,0x00,0x0E,0x05,0x0F,
  0x00,0x0D,0x02,0x0D
};

//
/*---Инициализация глобальных переменных---*/
unsigned char mas_name[6][8];            //Массив в ОЗУ пользовательских названий продуктов из 8 символов*/
unsigned int ADCx10;                     //Переменная измеренного значения проводимости (в ADC*10)
bool meassureOk = false;                 //Переменная корректности замера: 1-ОК, 0-ошибка
unsigned char akt=0;                     //1- признак активного текущего пункта меню
unsigned char b=0;                       //Переменная для автоповтора нажатой кнопки
unsigned char contrast=70;               //Контрастность дисплея: 0...100 (регулируется только у китайского дисплея)
volatile unsigned char rezh=1;           //Режим работы 0-выключено (с индикацией зарядки); 1-включено
volatile unsigned int schpow=0;          //Счетчик таймера отключения
unsigned char taym_off=2;                //Таймер выключения (0-выкл.;1-1мин;2-2мин;3-3мин;4-5мин)
unsigned char batter=0;                  //Уровень напряжения батареи
unsigned char yark=1;                    //Яркость подсветки (0...10 -> I=0...10мА)
unsigned char light=1;                   //Управление подсветкой 0-выкл., 1-вкл.
unsigned char ligh_off=2;                //Время выкл.подсв.по таймеру (0-выкл.;1-10с;2-15с;3-20с;4-30с;5-45с;6-60с)
unsigned char menu_cnt=0;                //Счетчик меню: 0-нач.,1-выбор продукта,2-измер.,3-настройки,4-нормы ПДК
unsigned char mnc_nach=0;                //Счетчик начального меню: 0-Измерение, 1-Настройки, 2-Нормы ПДК
unsigned char n_nazv=0;                  //Счетчик букв при редактировании названия продукта
unsigned char n_prod=0;                  //Счетчик номера проверяемых продуктов: 0...35
unsigned char mnc_izm=0;                 //Счетчик меню измерений: 0-замер,1-сохранить,2-статистика,3-очистка статист.,4-ред.назв
unsigned char mnc_nastr=0;               //Счетчик меню настроек: 0-время подсв.,1-яркость,2-таймер,3-звук,4-контрастность,5-Uакк,6-Rx
unsigned char mnc_PDK=0;                 //Счетчик меню норм ПДК проверяемых продуктов: 0...30
unsigned char sdvig_prod=0;              //Сдвиг отбражаемых пунктов меню проверяемых продуктов: 0...31
unsigned char sdvig_PDK=0;               //Сдвиг отбражаемых пунктов меню норм ПКД проверяемых продуктов: 0...26
unsigned int Ubat_mV=0;                  //Напряжение батареи в мВ
unsigned int Ubat=0;                     //Напряжение батареи в мВ/10
unsigned int vref=2560;                  //Опорное напряжение внутреннего ИОН АЦП МК в мВ (выв.29 (AREF) МК) для измер.батареи (по datasheet 2,3...2,7В)
unsigned int Uref=2560;                  //Опорное напряжение внутреннего ИОН АЦП МК в мВ (выв.29 (AREF) МК) для измер.проводимости
unsigned char sound=1;                   //Управление звуком (0-выкл., 1-вкл.)
volatile unsigned char T_bat=1;          //1 - признак прошедшего интервала 0,26 сек для измерения напряжения аккумулятора
volatile unsigned char t_026sec=0;       //Счетчик 0,26-секундных интервалов
volatile unsigned char T_menu=1;         //1 - признак прошедшего интервала 0,26 сек для вывода меню
volatile unsigned char zar=0;            //Режим зарядки 0-ЗУ не подключено; 1-зарядка; 2-зарядка завершена
unsigned char zam=0;                     //0-не было ни одного замера, 1-был замер, но не сохранен, 2-был замер и сохранен, 3-непрерывное измерение
//
/*---Инициализация переменных в EEPROM---*/
unsigned char EEMEM Econtrast=70;        //Контрастность дисплея: 0...100
unsigned char EEMEM Etaym_off=2;         //Таймер выключения (0-выкл.;1-1мин;2-2мин;3-3мин;4-5мин)
unsigned char EEMEM Eyark=1;             //Яркость подсветки (0...10 -> I=0...10мА)
unsigned char EEMEM Eligh_off=2;         //Время выкл.подсв.по таймеру (0-выкл.;1-10с;2-15с;3-20с;4-30с;5-45с;6-60с)
unsigned char EEMEM Emenu_cnt=0;         //Счетчик меню: 0-нач.,1-выбор продукта,2-измер.,3-настройки,4-нормы ПДК
unsigned char EEMEM Emnc_nach=0;         //Счетчик начального меню: 0-измерение,1-настройки,2-нормы ПДК
unsigned char EEMEM En_prod=0;           //Счетчик номера проверяемых продуктов: 0...35
unsigned char EEMEM Emnc_izm=0;          //Счетчик меню измерений: 0-замер,1-сохр.,2-статистика,3-редактир.назв,4-очистка статист.,5-подтвержд.
unsigned char EEMEM Emnc_nastr=0;        //Счетчик меню настроек: 0-время подсв.,1-яркость,2-таймер,3-звук,4-Uакк,5-Rx
unsigned char EEMEM Emnc_PDK=0;          //Счетчик меню норм ПДК проверяемых продуктов: 0...30
unsigned char EEMEM Esdvig_prod=0;       //Сдвиг отбражаемых пунктов меню проверяемых продуктов: 0...31
unsigned char EEMEM Esdvig_PDK=0;        //Сдвиг отбражаемых пунктов меню норм ПКД проверяемых продуктов: 0...26
unsigned int EEMEM Evref=2560;           //Опорное напряжение внутреннего ИОН АЦП МК в мВ (на выв.29 (AREF) МК) для измер.батареи
unsigned int EEMEM EUref=2560;           //Опорное напряжение внутреннего ИОН АЦП МК в мВ (на выв.29 (AREF) МК) для измер.проводимости
unsigned char EEMEM Esound=1;            //Управления звуком (0-выкл., 1-вкл.)
//
/*----Инициализация внутренних функций----*/
unsigned char autopovt(unsigned char k, unsigned char t);//Функция автоповтора нажатой кнопки
void batt (void);                        //Измерение напряжения аккумулятора с 10-разр.точностью и управления зарядкой
unsigned int clk_Gx10 (unsigned int ADC10);//Функция вычисления проводимости продукта в мкСм*10
unsigned int clk_Rx (unsigned int ADC10);//Функция вычисления сопротивления продукта в Омах
unsigned char knopka (void);             //Определение нажатых кнопок
void LoadEE(void);                       //Загрузка глобальных переменных из EEPROM
void menu (void);                        //Функция вывода меню
void menumess (unsigned char ms);        //Функция вывода меню сообщений
void off_power (void);                   //Процедура выключения питания
void opros(void);                        //Опрос кнопок
void ozhid (unsigned char kn);           //Ожидание отпускания кнопки
void highlight ();                    //Функция управления подсветкой
void saveMeasure (void);                 //Функция сохранения результатов замера продукта
void SaveEE(void);                       //Сохранение глобальных переменных в EEPROM
void tayms (unsigned int t);             //Пауза в мс (1...65535)
void wr_batt (void);                     //Функция вывода символа батарейки
void meassure ();                        //Функция проведения замера продукта
//


#include "sound.h"
#include "logo.h"


/*----Функция обработки прерываний от нажатия кнопки "Вкл./Выкл."----*/
ISR(INT2_vect) {                         //Прерывание по спаду INT2
	_delay_ms(30);                       //Пауза для антидребезга
  if (bit_is_clear(PINB,ONOFF))          //Если нажата кнопка "Вкл./Выкл."
  { if (rezh==1)                         //Если режим работы
    { rezh=0;                            //Признак выключения
      beep(0);                          //Подача длинного звукового сигнала перед выключением
      if (zar!=1)                        //Если не процесс зарядки
      { GICR=0x00;                       //00000000 - запрещение внешних прерываний INT2,INT1,INT0
        off_power();                     //Процедура выключения питания
      }
    }
    else                                 //Иначе, если режим индикации процесса зарядки
    { if (knopka()==1)                   //Если нажата только кнопка "Вкл./Выкл."
      { rezh=1;                          //Переход в режим работы
        beep(1); beep(4);              //Подача 2-х коротких звуковых сигналов при включении (3, 3.5 кГц)
        schpow=0;                        //Сброс счетчика 0,262144 секундных интервалов
        if (light==0)                    //Если подсветка была выключена по таймеру
        { light=1;                       //Установка признака включенной подсветки
          highlight();                    //Управление подсветкой
        }
      }
    }
  }
  if (bit_is_set(GIFR,INTF2))            //Если установлен флаг прерывания от дребезга контактов
  GIFR=0b0010000;                        //00100000-сброс флага внешнего прерывания INTF2
  return;
}
//
/*----Функция обработки прерываний от таймера-счетчика 1----*/
ISR(TIMER1_OVF_vect)                     //Прерывание по переполнению т.сч.1 (каждые 0,262144с)
{ //TIMSK&=~_BV(TOIE1);                    //TOIE1=1 - запрещ.прерыв.по переполн.т.сч.1 (через каждые 0,2097152 сек)
                                         //чтобы не было повторного вызова из вызываемых из ISR(TIMER0_OVF_vect)
                                         //функций и переполнения стека
  t_026sec++;                            //Инкремент счетчика 0.26 сек.интервалов
  if (t_026sec>3) t_026sec=0;            //Если прошло 4 такта - сброс счетчика 0.26 сек.интервалов
  T_menu=1;                              //Признак прошедшего интервала 0,262144 сек для вывода меню
  T_bat=1;                               //Признак прошедшего интервала 0,262144 сек для измерения напряжения аккумулятора
  schpow++;                              //Инкремент счетчика 0,262144 секундных интервалов
  { if (schpow>50000) schpow=0;          //Сброс schpow после 3,6 часов на случай выключенного таймера
  }
  //TIMSK|=_BV(TOIE1);                     //TOIE1=1 - разреш.прерыв.по переполн.т.сч.1 (через каждые 0,262144 сек)
  return;
}
//
/*----Основная функция----*/
int main (void) {
	DDRA = 0b00000100; PORTA = 0b11001111;     //PA1=1 (выход), PA4,5 - входы без подт.рез.(АЦП)
	DDRB = 0b10111001; PORTB = 0b01000110;     //PB7,5,4,3,0 - выходы, PB6,2,1 - входы с подт.рез.
	DDRC = 0b00001010; PORTC = 0b11110101;     //PC1,3=0 - выходы
	DDRD = 0b10110000; PORTD = 0b01001111;     //PD7,5,4=0 - выходы, PD3,2,0 - входы с подт.резист.
	ACSR = 0b10000001;                       //Выключение компаратора МК (ACSR(ACD)=1)
	LoadEE();                              //Чтение глобальных переменных из EEPROM
	MCUCSR&=~_BV(ISC2);                    //ISC2=0 - прерывание INT2 по спаду
	GICR |= _BV(INT2);                       //INT2=1 - разрешение внешнего прерывания INT2
	TCCR1B=0b00000010;                     //Пуск тайм.сч.1 (Fclk/8/65536=3,8146972Гц, обычный режим)
	TIMSK|=_BV(TOIE1);                     //TOIE1=1 - разреш.прерыв.по переполн.т.сч.1 (каждые 0,262144 сек)
	sei();                                 //Общее разрешение прерываний
	TCCR2=0b01101001;                      //Пуск т.сч.ШИМ подсветки (FastPWM, OC2=0 при совпад.,OC2=1 при TOP=255,F=2МГц/1/256=7812,5Гц

	//Установка скважности 2 т.сч.0 для тестового сигнала измерения
	OCR0 = 127;                              //Тестовый сигнал - меандр
	if ((mnc_nach == 1) && (menu_cnt == 3) && (mnc_nastr > 4)) {//Если меню калибровки
		TCCR0 = 0b01101001;                    //Пуск т.сч.0 тестового сигнала (FastPWM, OC2=0 при совпад.,OC2=1 при TOP=255,F=2МГц/1/256=7812,5Гц
	}

	wdt_enable(WDTO_2S);
	highlight();                            //Установка яркости подсветки
	LcdInit();                             //Инициализация дисплея и интерфейса SPI
	LcdContrast(contrast+SDV_CONTR);       //Установка выбранной контрастности дисплея 0...100 -> SDV_CONTR...100+SDV_CONTR
	// Вывод заставки
	LcdImage(lcd_logo_data);
	beep(1); beep(4);                    //Подача 2-х коротких звуковых сигналов при включении (3, 3.5 кГц)

wdt_reset();
	_delay_ms(1500);                        //Пауза для индикации заставки

	while (knopka() == 1) {                    //Ожидание отпускания кнопки Вкл./Выкл.
		batt();                              //Измерение напряжения аккумулятора
	}

	menu();                                //Вывод меню
	// Начало рабочего цикла
wdt_reset();
//wdt_enable(WDTO_1S);
	while(1) {
wdt_reset();                               //Бесконечный цикл
	opros();                             //Опрос кнопок
    batt();                              //Измерение напряжения аккумулятора и управления зарядкой
    menu();                              //Вывод меню
  //Проверка выключения подсветки по таймеру
    if (ligh_off>0)                      //Если таймер разрешен
    { if (schpow > pgm_read_byte(massloff+ligh_off)) //Если сработал таймер выключения подсветки
      { light=0;                         //Установка признака выключенной подсветки
        highlight();                      //Управление подсветкой
      }
    }
  //Проверка выключения питания по таймеру
    if (schpow > pgm_read_word(masstoff+taym_off)) { //Если сработал таймер выключения питания
		rezh = 0;                            //Установка признака выключения
    }
  //Процедура выключения питания
    if ((rezh==0)&&(zar!=1))             //Если установлен признак выключения и нет зарядки
    { menumess(zar);                     //Вывод сообщения "Выключение" или "Аккумулятор заряжен. Выключение"
      if (light==0)                      //Если подсветка была выключена по таймеру
      { light=1;                         //Установка признака включенной подсветки
        highlight();                      //Управление подсветкой
      }
      beep(0);                          //Подача длинного звукового сигнала 0,5 сек, 3 кГц
      unsigned char c=0;                 //Счетчик временных интервалов для процедуры выключения
      GICR &= ~_BV(INT2);                  //INT2=0 - запрещение внешнего прерывания INT2 (кнопка Вкл./Выкл.)
      while (c<200) {                     //Возможность отмены выключения в течение 5 сек
		_delay_ms(25);                       //Опрос состояния кнопок - через каждые 25 мс
        if (knopka()!=0)                 //Если была нажата какая-либо кнопка
        { schpow=0;                      //Сброс счетчика таймера выключения
          T_menu=1;                      //Установка признака прошедшего интервала 0,262144 сек для вывода меню
          light=1;                       //Установка признака включенной подсветки
          highlight();                    //Управление подсветкой
          menu();                        //Вывод меню для стирания надписи "Выключение" ("Shut down")
          beep(3);                      //Подача 3-х коротких звуковых сигналов при повторном включении
          while (knopka()!=0);           //Ожидание отпускания кнопок
          _delay_ms(50);                     //Пауза антидребезга
          rezh=1;                        //Установка признака рабочего режима
          GIFR=0b0010000;                //00100000-сброс флага внешнего прерывания INTF2
          GICR |= _BV(INT2);               //INT2=1 - разрешение внешнего прерывания INT2
          break;                         //Досрочный выход из цикла
        }
        c++;                             //Увеличение счетчика на 1
      }
      if ((rezh==0)&&(zar!=1))           //Если установлен признак выключения
      { beep(0);                        //Подача длинного звукового сигнала 0,5 сек, 3 кГц
        off_power();                     //Процедура выключения питания
      }
      else GICR|=_BV(INT2);              //Иначе INT2=1 - разрешение внешнего прерывания INT2
    }
  }
}
//
#include "keyboard.h"

//
/*----Функция выключения питания----*/
void off_power () {                    //Процедура выключения питания
	wdt_reset();
	SaveEE();                              //Сохранение измененных глобальных переменных в EEPROM
	TCCR2 = 0;                               //00000000 - Стоп тайм.сч.2 - выключение подсветки
	LcdClear();                            //Очистка ЖКИ для эффекта быстрого выключения при удержании кнопки "Вкл./Выкл."
	wdt_disable();
	PORTD &= ~_BV(PD7);                      //PD7=0 - уст.0 на выводе упр.подсветкой
	PORTB &= ~_BV(CHARGE);                   //CHARGE=0 - выключение ключа зарядки
	PORTA &= ~_BV(POWER);                    //POWER=0 - выключение питания
	while(1);                              //Зацикливание пока напряжение не уменьшится до сброса МКs
}
//
#include "draw.h"
//
/*----Функция управления яркостью подсветки----*/
void highlight() {                     //Частота ШИМ на выходе OC2(PD7): 2МГц/256=7812,5 Гц
	if (light ==0 ||yark == 0) 
		OCR2 = 0;     //Если подсветка выключена - OCR2=0
	else 
		OCR2 = (yark+212);                  //yark=1...10 -> OCR2=213...222
}
//
/*-----Измерение напряжения аккумулятора с 10-разр. точностью и управление зарядкой-----*/
void batt () {
	if (T_bat == 0) 
		return;                  //Если еще не прошло 0.26 сек - выход
  unsigned char n=0;                     //Счетчик замеров
  unsigned int dADC=0;                   //Переменная для хранения измеренной величины
  unsigned long mVolt=0;                 //Переменная для перевода измеренной величины в мВ
  ADMUX=0b11000100;                      //11000100 Инициализация АЦП МК: ADC4,правое выравнивание,ИОН-внутренний
  while (n<20)                           //Цикл из N=20 замеров
  { while (bit_is_set(ADCSRA,ADSC));     //Ожидание завершения преобразования
    cli();                               //Запрещение прерываний
    ADCSRA=0b11000100;                   //11000100 - Пуск АЦП (Кдел=16, f=125 кГц, однократн.)
    while (bit_is_set(ADCSRA,ADSC));     //Ожидание завершения преобразования
    dADC=dADC+ADCL;                      //Чтение младшего разряда АЦП
    dADC=dADC+(256*ADCH);                //Чтение старшего разряда АЦП
    sei();                               //Разрешение прерываний
    n++;
  }
  dADC=dADC+10;                          //Коррекция последнего разряда (+ N/2)
  mVolt=dADC;                            //Преобразование типа unsigned int в unsigned long
/* ACD=((Uбат/Кдел)/Vref)*1024)
   Vref=2.4В_2.56В_2.7В или (2.56В)
   Kдел=(Rдел_верхн+Rдел_нижн||Rвх_ацп_мк)/(Rдел_нижн||Rвх_ацп_мк) - коэф.деления делителя
   Kдел=(100к+100к||100M)/(100к||100M)=(100к+99,9к)/99,9к=2,001 => 2

   Измеренное напряжение для N замеров:
   Uбат=(ACD/N)*Vref*Кдел/1024

   Вычисление мВ:
   1) mVolt=(ACD/N)*(Vref/1024)*Kдел=(ACD/N)*(2500/1024)*2=(ACD/N)*(5000)/1024=
   =(ACD*5000)/(1024*N)=(ACD*5000)/20480 (для N=20)

   Вычисление мВ с подстроечной константой Vref:
   2) mVolt=(ACD/N)*(Vref/1024)*Kдел=(ACD*Vref)*2/(N*1024)=(ACD*Vref)/(N*512)=
   =(ACD*Vref)/10240 (для N=20)

   Для отображения 3-х разрядов в формате Х.ХХ В результат делится на 10 с округлением
   (прибавляется 5 перед делением)
   1) mVolt=((ACD*5000)+5)/204800  - 1 вариант (N=20)
   2) mVolt=((ACD*vref)+5)/102400  - 2 вариант (N=20)
*/
  mVolt=((mVolt*vref)+5)/10240;          //2 вариант (N=20)
  Ubat_mV=mVolt;                         //Преобразование типа unsigned long в unsigned int
  dADC=mVolt/10;                         //Преобразование типа unsigned long в unsigned int
  if (dADC>387) batter=5;                //1 (Uбат>3,87В)
  else
  { if (dADC>375) batter=4;              //0,75 (Uбат>3,75В)
    else
    { if (dADC>368) batter=3;            //0,5 (Uбат>3,68В)
      else
      { if (dADC>360) batter=2;          //0,25 (Uбат>3,6В)
        else
        { if (dADC>300) batter=1;        //0  (Uбат>3,0В)
          else
          { batter=0;
            if ((light==1)&&(yark>0))    //Если подсветка включена
            { yark--;                    //Уменьшение яркости подсветки
              highlight();                //Вызов функции управления подсветкой
              beep(5);                  //Короткий звук 2,5 кГц
            }
            else
            { menumess(1);               //Вывод сообщения "Аккумулятор разряжен! Выключение!"
              beep(0);                  //Подача длинного звукового сигнала 0,5 сек, 3 кГц
              _delay_ms(2000);               //Пауза для возможности прочтения сообщения
              off_power();               //Процедура выключения питания
            }
          }
        }
      }
    }
  }
  Ubat=dADC;
//Проверка процесса зарядки и управление ключом зарядки
  if (bit_is_set(PINB,ZU))               //Если ЗУ не подключено (ZU=1)
  { if (zar>0)                           //Если был процесс зарядки и ЗУ отключено вручную
    { zar=0;                             //Признак выключ.ЗУ
      if (rezh==1) beep(5);             //Если режим работы - 1 короткий звук 0,1 сек, 2,5 кГц
    }
  }
  else                                   //Иначе, если ЗУ подключено
  { if (zar==0)                          //Если процесс зарядки ещё не был начат
    { if (Ubat<ZAR_POR)                  //Если напряжение аккумулятора меньше порога прекращения зарядки
      { zar=1;                           //Уст.признака зарядки
      }
      else zar=2;                        //Иначе - установка признака завершения зарядки
      schpow=0;                          //Сброс счетчика 0,262144 секундных интервалов
      if (light==0)                      //Если подсветка была выключена по таймеру
      { light=1;                         //Установка признака включенной подсветки
        highlight();                      //Управление подсветкой
      }
      beep(4);                          //1 короткий звук 0,1 сек, 3,5 кГц
    }
    else
    { if (zar==1)                        //Иначе, если идет процесс зарядки
      { if (Ubat>=ZAR_POR)               //Если напряжение аккумулятора >= порога прекращения зарядки
        { zar=2;                         //Установка признака завершения зарядки
          if (rezh==1)                   //Если режим работы
          { schpow=0;                    //Сброс счетчика 0,262144 секундных интервалов
            if (light==0)                //Если подсветка была выключена по таймеру
            { light=1;                   //Установка признака включенной подсветки
              highlight();                //Управление подсветкой
            }
            menumess(3);                 //Вывод сообщения "Аккумулятор заряжен!"
            beep(4);                    //1 короткий звук 0,1 сек, 3,5 кГц
            _delay_ms(1000);                 //Пауза 1 с для прочтения сообщения
          }
        }
      }
      else
      { if (zar==2)                      //Иначе, если процесс зарядки завершен
        { if (Ubat<360) zar=1;           //Если напряжение аккумулятора меньше 3,6В - включение повторной зарядки
        }
      }
    }
  }
  if (zar==1) PORTB|=_BV(CHARGE);        //Если установлен признак зарядки - включение ключа зарядки  CHARGE=1
  else PORTB&=~_BV(CHARGE);              //Иначе - выключение ключа зарядки  CHARGE=0
//
  T_bat=0;                               //Сброс признака прошедшего 0,26-секундного интервала
  return;
}
//
/*-----Проведение замера продукта-----*/
void meassure() {
	unsigned int dADC = 0;                   //Переменная для хранения измеренной величины
	ADMUX = 0b11000101;                      //11000101 Инициализация АЦП МК: ADC5,правое выравнивание,ИОН-внутренний
	for (uint8_t n = 0; n < 10; n++) {		// Цикл из 10 замеров
		wdt_reset();
		while (bit_is_set(ADCSRA, ADSC));     //Ожидание завершения преобразования
		wdt_reset();
		cli();                               //Запрещение прерываний
		ADCSRA = 0b11000100;                   //11000100 - Пуск АЦП (Кдел=16, f=125 кГц, однократн.)
		while (bit_is_set(ADCSRA,ADSC));     //Ожидание завершения преобразования
		wdt_reset();
		dADC = dADC + ADCL;                      //Чтение младшего разряда АЦП
		dADC = dADC + (256*ADCH);                //Чтение старшего разряда АЦП
		sei();                               //Разрешение прерываний
	}
	ADCx10 = dADC;                           //Перезапись в глобальную переменную
}
//
/*-----Функция сохранения результатов замера продукта в EEPROM-----*/
void saveMeasure (void) {
	unsigned char N=21;                    //Номер перезаписываемой ячейки
  unsigned char i=0;                     //Счетчик
  unsigned char pr=0;                    //Признак переполнения
  unsigned char masst1[20];              //Временный рабочий массив статистики в ОЗУ для выбранного продукта, считанный из EEPROM
  unsigned int masst2[20]={0};           //Временный рабочий массив статистики в ОЗУ для выбранного продукта для записи в EEPROM
  unsigned int Gx;                       //Измеренная проводимость
  unsigned int Gmax;                     //Максимум проводимости
  unsigned int Gmin;                     //Минимум проводимости
  unsigned int max1;                     //Максимум замера АЦП, считанный из EEPROM
  unsigned int min1;                     //Минимум замера АЦП, считанный из EEPROM
  unsigned int max2;                     //Максимум замера АЦП для записи в EEPROM
  unsigned int min2;                     //Минимум замера АЦП для записи в EEPROM
  unsigned int n;                        //Число замеров
  unsigned long dat;                     //Вспомогательная переменная для вычислений
//
  Gx=clk_Gx10(ADCx10);                   //Вычисление измеренной проводимости
  n=eeprom_read_word(mas_Nzam+n_prod);   //Считывание выполненного числа замеров из EEPROM
  if (n<65535)                           //Если нет переполнения
  { n++;                                 //Инкремент числа замеров
    eeprom_write_word(mas_Nzam+n_prod, n);//Запись выполненного числа замеров в EEPROM
  }
  if (n==1)                              //Если первый замер выбранного продукта
  { Gmax=Gx;
    Gmin=Gx;
    max2=ADCx10;
    min2=ADCx10;
  }
  else                                   //Иначе, если не первый замер выбранного продукта
  { max1=eeprom_read_word(&mas_lim[0][n_prod]);//Считывание максимального значения замера АЦП
    Gmax=clk_Gx10(max1);                 //Вычисление максимального значения проводимости в мкСм*10
    min1=eeprom_read_word(&mas_lim[1][n_prod]);//Считывание минимального значения замера АЦП
    Gmin=clk_Gx10(min1);                 //Вычисление минимального значения проводимости в мкСм*10
  //Считывание статистики замеров из EEPROM в ОЗУ в массив masst1[]
    i=0;
    while (i<20)
    { masst1[i]=eeprom_read_byte(&mas_stat[n_prod][i]);
      i++;
    }
  //
    if ((Gx!=Gmin)&&(Gmax==Gmin))        //Если есть отличия измеренного значения после первого замера
    { if (Gx<Gmin)                       //Если измеренная проводимость меньше, чем при первом замере
      { max2=max1;                       //Максимум - без изменений
        min2=ADCx10;                     //Перезапись минимума измеренным значением
        masst2[0]=1;                     //Запись одного замера в ячейку минимума
        masst2[19]=n-1;                  //Запись оставшихся замеров в ячейку максимума
      }
      else                               //Иначе, если измеренная проводимость больше, чем при первом замере
      { max2=ADCx10;                     //Перезапись максимума измеренным значением
        min2=min1;                       //Минимум - без изменений
        masst2[19]=1;                    //Запись одного замера в ячейку максимума
        masst2[0]=n-1;                   //Запись оставшихся замеров в ячейку минимума
      }
    }
    else                                 //Иначе, если Gmax!=Gmin
    { if (Gx==Gmax)
      { i=0;
        while (i<20)                     //Перезапись массива masst1[] в masst2[]
        { masst2[i]=masst1[i];
          i++;
        }
        N=19;                            //Номер инкрементируемой ячейки
        max2=max1;                       //Максимум - без изменений
        min2=min1;                       //Минимум - без изменений
      }
      else
      { if ((Gmin<=Gx)&&(Gx<Gmax))
        { dat=Gx;
          N=((dat-Gmin)*20)/(Gmax-Gmin); //Вычисление номера инкрементируемой ячейки
          min2=min1;                     //Минимум - без изменений
          max2=max1;                     //Максимум - без изменений
          i=0;
          while (i<20)                   //Перезапись массива masst1[] в masst2[]
          { masst2[i]=masst1[i];
            i++;
          }
        }
        else
        { if (Gmax<Gx)                   //Иначе, если Gmax<Gx
          { dat=Gmax;
            min2=min1;                   //Минимум - без изменений
            max2=ADCx10;                 //Перезапись максимума измеренным значением
            i=0;
            while (i<20)                 //Перезапись ячеек 0...19
            { N=(((dat-Gmin)*i*10)/(Gx-Gmin)+5)/10;//Перенос данных с ячейки i в ячейку N
              masst2[N]=masst2[N]+masst1[i];
              i++;
            }
            N=19;                        //Номер инкрементируемой ячейки
          }
          else
          { if (Gx<Gmin)                 //Иначе, если Gx<Gmin
            { dat=Gmax;
              min2=ADCx10;               //Перезапись минимума измеренным значением
              max2=max1;                 //Максимум - без изменений
              i=20;
              do                         //Перезапись ячеек 19...1
              { i--;
                N=(205-((dat-Gmin)*(200-i*10))/(Gmax-Gx))/10;//Перенос данных с ячейки i в ячейку N
                if (N>19) N=19;          //Ограничение по последней ячейке
                masst2[N]=masst2[N]+masst1[i];
              } while (i>0);
              N=0;                       //Номер инкрементируемой ячейки
            }
          }
        }
      }
      if (N<20)                          //Если была перестановка ячеек массива статистики
      { masst2[N]++;                     //Инкремент N-ой ячейки
        i=0;
        while (i<20)                     //Проверка нового массива на переполнение (>255)
        { if (masst2[i]>255)
          { pr=1;                        //Установка признака переполнения
            break;                       //Досрочный выход из цикла
          }
          i++;
        }
        if (pr>0)                        //Если обнаружилось переполнение
        { masst2[N]--;                   //Удаление добавленногозамера из N-ой ячейки
          i=0;
          while (i<20)
          { if (masst2[i]>>1);           //Деление на 2 каждой ячейки
            i++;
          }
          masst2[N]++;                   //Инкремент N-ой ячейки
        }
      }
    }
  }
//Перезапись массивов EEPROM
  if (min2!=min1) eeprom_write_word(&mas_lim[1][n_prod], min2);//Запись минимального значения замера АЦП
  if (max2!=max1) eeprom_write_word(&mas_lim[0][n_prod], max2);//Запись максимального значения замера АЦП
  i=0;
  while (i<20)
  { if (masst2[i]!=masst1[i]) eeprom_write_byte(&mas_stat[n_prod][i], masst2[i]);//Перезапись массива статистики
    i++;
  }
  return;
}
/*-----Пауза ms-----*/
void tayms (unsigned int tt){
	volatile unsigned int t = tt;
	volatile unsigned int t1;
	while (t != 0) {
		t1 = 1996;
		while (--t1 != 0);
		t--;
	}
//	return;
}
//

//
/*-----Функция вычисления сопротивления продукта в Омах-----*/
unsigned int clk_Rx (unsigned int ADC10)
{ /*
        3В*Rи                 3В                    U
  Rx = ------- - Rи;     U = ----- *Rи;      ADC = ----*1024;
          U                  Rx+Rи                 Uref
  
  Rи=1500 Ом - нижнее плечо делителя, с учетом ||1МОм Rи=1497,75 Ом ~ 1498 Ом;
  3000 мВ - измерительное напряжение;
  
        3В*Rи*1024          / 3000*1498*1024    ADCx10 + 5 \
  Rx = ------------ - Rи = | ---------------- / ----------- | - 1498
         Uref*ADC           \     Uref             10      /
  */
  unsigned int Rx;
  unsigned long r;
  if ((ADC10<180)||(ADC10>=10230))        //Если ADC10<180 (>98 кОм) или >=10230(<=259 Ом)
  { Rx=65535;                             //Установка признака ????
  }
  else
  { r=((460185600/Uref)*10)/((ADC10+5)/10)-1498;//Rизм=1.5кОм, Nзам=10
    if (r>65535) Rx=65535;
    else Rx=r;
  }
  return(Rx);
}
//
/*-----Функция вычисления проводимости продукта в мкСм*10-----*/
unsigned int clk_Gx10 (unsigned int ADC10)
{ /*
        1                    1000000
  Gx = ---- (в См);    Gx = --------- (в мкСм);
        Rx                     Rx
  */
  unsigned int Gx10;
  Gx10=clk_Rx(ADC10);                    //Вычисление Rx
  if (Gx10!=65535)                       //Если Rx неизвестно - установлен признак ????
  { Gx10=((100000000/Gx10)+5)/10;        //Иначе - вычисление с округлением последнего знака
  }
  return(Gx10);
}
#include "lcd_utils.h"
//
/*----Функция чтения глобальных переменных из EEPROM----*/
void LoadEE(void)
{ unsigned char i=0;
  unsigned char j=0;
  contrast=eeprom_read_byte(&Econtrast); //Контрастность дисплея (0...100)
  if (contrast>100) contrast=80;         //По умолчанию - 80%
  taym_off=eeprom_read_byte(&Etaym_off); //Таймер выключения (0-выкл.;1-1мин;2-2мин;3-3мин;4-5мин)
  if (taym_off>4) taym_off=2;            //По умолчанию - 2мин.
  yark=eeprom_read_byte(&Eyark);         //Яркость подсветки (0...10 -> I=0...10мА)
  if (yark>10) yark=1;                   //По умолчанию - яркость 1
  ligh_off=eeprom_read_byte(&Eligh_off); //Время выкл.подсв.по таймеру (0-выкл.;1-10с;2-15с;3-20с;4-30с;5-45с;6-60с)
  if (ligh_off>6) ligh_off=2;            //По умолчанию - 15с
  mnc_nach=eeprom_read_byte(&Emnc_nach); //Счетчик начального меню: 0-измер.,1-настройки,2-нормы ПДК
  if (mnc_nach>2) mnc_nach=0;            //По умолчанию - нач.меню
  menu_cnt=eeprom_read_byte(&Emenu_cnt); //Счетчик меню: 0-нач.,1-выбор продукта,2-измер.,3-настройки,4-нормы ПДК
  if (menu_cnt>4) menu_cnt=0;            //По умолчанию - нач.меню
  n_prod=eeprom_read_byte(&En_prod);     //Счетчик проверяемых продуктов: 0...35
  if (n_prod>35) n_prod=0;               //По умолчанию - №0
  mnc_izm=eeprom_read_byte(&Emnc_izm);   //Счетчик меню измерений: 0-замер,1-сохранить,2-статистика,3-очистка статист.,4-ред.назв
  if ((mnc_izm>4)||(mnc_izm==1)) mnc_izm=0;//По умолчанию - замер, сохранять ещё нечего
  if ((n_prod<30)&&(mnc_izm==4)) mnc_izm=3;//Если название проверяем.продукта из flash и пункт Ред.назв.->Очистка статист.
  mnc_nastr=eeprom_read_byte(&Emnc_nastr);//Счетчик меню настроек: 0-время подсв.,1-яркость,2-таймер,3-звук,4-Uакк,5-Rx
  if (mnc_nastr>6) mnc_nastr=0;          //По умолчанию - 0 (время подсв.)
  mnc_PDK=eeprom_read_byte(&Emnc_PDK);   //Счетчик меню норм ПДК проверяемых продуктов: 0...30
  if (mnc_PDK>30) mnc_PDK=0;             //По умолчанию - 0
  sdvig_prod=eeprom_read_byte(&Esdvig_prod);//Сдвиг отбражаемых пунктов меню проверяемых продуктов: 0...31
  if (sdvig_prod>31) sdvig_prod=0;       //По умолчанию - 0
  sdvig_PDK=eeprom_read_byte(&Esdvig_PDK);//Сдвиг отбражаемых пунктов меню норм ПКД проверяемых продуктов: 0...26
  if (sdvig_PDK>26) sdvig_PDK=0;         //По умолчанию - 0
  vref=eeprom_read_word(&Evref);         //Опорное напряжение внутреннего ИОН АЦП МК в мВ (на выв.29 (AREF) МК) для измер.батареи
  if ((vref>2800)||(vref<2200)) vref=2560;//По умолчанию - 2,56В
  Uref=eeprom_read_word(&EUref);         //Опорное напряжение внутреннего ИОН АЦП МК в мВ (на выв.29 (AREF) МК) для измер.проводимости
  if ((Uref>2800)||(Uref<2200)) Uref=2560;//По умолчанию - 2,56В
  sound=eeprom_read_byte(&Esound);       //Управление звуком (0-выкл., 1-вкл.)
  if (sound>1) sound=1;                  //По умолчанию - звук включен
//Чтение массива из EEPROM-памяти пользовательских названий продуктов из 8 символов
  while (i<6)
  { j=0;
    while (j<8)
    { mas_name[i][j]=eeprom_read_byte(&Emas_name[i][j]);
      j++;
    }
    i++;
  }
//Проверка корректности счетчиков меню и коррекция при необходимости
//Счетчик начального меню mnc_nach: 0-Измерение, 1-Настройки, 2-Нормы ПДК
//Счетчик меню menu_cnt: 0-нач.,1-выбор продукта,2-измер.,3-настройки,4-нормы ПДК
  if ((mnc_nach==0)&&(menu_cnt>2)) menu_cnt=0;
  if ((mnc_nach==1)&&(menu_cnt!=3)) menu_cnt=0;
  if ((mnc_nach==2)&&(menu_cnt!=4)) menu_cnt=4;
}
//
/*----Функция сохранения глобальных переменных в EEPROM----*/
void SaveEE (void)
{ unsigned char i=0;
  unsigned char j=0;
  if (eeprom_read_byte(&Econtrast)!=contrast) eeprom_write_byte(&Econtrast, contrast);//Контрастность дисплея
  if (eeprom_read_byte(&Etaym_off)!=taym_off) eeprom_write_byte(&Etaym_off, taym_off);//Таймер выключения
  if (eeprom_read_byte(&Eyark)!=yark) eeprom_write_byte(&Eyark, yark);//Яркость подсветки
  if (eeprom_read_byte(&Eligh_off)!=ligh_off) eeprom_write_byte(&Eligh_off, ligh_off);//Время выкл.подсв.по таймеру
  if (eeprom_read_byte(&Emenu_cnt)!=menu_cnt) eeprom_write_byte(&Emenu_cnt, menu_cnt);//Счетчик меню
  if (eeprom_read_byte(&Emnc_nach)!=mnc_nach) eeprom_write_byte(&Emnc_nach, mnc_nach);//Счетчик начального меню
  if (eeprom_read_byte(&En_prod)!=n_prod) eeprom_write_byte(&En_prod, n_prod);//Счетчик проверяемых продуктов
  if (eeprom_read_byte(&Emnc_izm)!=mnc_izm) eeprom_write_byte(&Emnc_izm, mnc_izm);//Счетчик меню измерений
  if (eeprom_read_byte(&Emnc_nastr)!=mnc_nastr) eeprom_write_byte(&Emnc_nastr, mnc_nastr);//Счетчик меню настроек
  if (eeprom_read_byte(&Emnc_PDK)!=mnc_PDK) eeprom_write_byte(&Emnc_PDK, mnc_PDK);//Счетчик меню норм ПДК проверяемых продуктов
  if (eeprom_read_byte(&Esdvig_prod)!=sdvig_prod) eeprom_write_byte(&Esdvig_prod, sdvig_prod);//Сдвиг отбражаемых пунктов меню проверяемых продуктов
  if (eeprom_read_byte(&Esdvig_PDK)!=sdvig_PDK) eeprom_write_byte(&Esdvig_PDK, sdvig_PDK);//Сдвиг отбражаемых пунктов меню норм ПКД проверяемых продуктов
  if (eeprom_read_word(&Evref)!=vref) eeprom_write_word(&Evref, vref);//Опорное напряжение внутреннего ИОН АЦП МК в мВ (на выв.29 (AREF) МК) для измер.батареи
  if (eeprom_read_word(&EUref)!=Uref) eeprom_write_word(&EUref, Uref);//Опорное напряжение внутреннего ИОН АЦП МК в мВ (на выв.29 (AREF) МК) для измер.проводимости
  if (eeprom_read_byte(&Esound)!=sound) eeprom_write_byte(&Esound, sound);//Управление звуком
//Запись массива пользовательских названий продуктов из 8 символов из ОЗУ в EEPROM
  while (i<6)
  { j=0;
    while (j<8)
    { if (eeprom_read_byte(&Emas_name[i][j])!=mas_name[i][j])
      { eeprom_write_byte(&Emas_name[i][j], mas_name[i][j]);
      }
      j++;
    }
    i++;
  }
  return;
}
//
/*
--------------------------------------------------------------------------------
  Оригинальный дисплей Nokia 3310:
  
  Program:    19018 bytes (58.0% Full) (максимум - 32768 bytes)
(.text + .data + .bootloader)

  Data:        653 bytes (31.9% Full) (максимум - 2048 bytes)
(.data + .bss + .noinit)

  EEPROM:      1001 bytes (97.8% Full) (максимум - 1024 bytes)
(.eeprom)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
  Китайский дисплей:
  
  Program:    19020 bytes (58.0% Full) (максимум - 32768 bytes)
(.text + .data + .bootloader)

  Data:        654 bytes (31.9% Full) (максимум - 2048 bytes)
(.data + .bss + .noinit)

  EEPROM:      1001 bytes (97.8% Full) (максимум - 1024 bytes)
(.eeprom)
--------------------------------------------------------------------------------
*/
//
